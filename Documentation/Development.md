# Development

Few notes that should help to better understand the development process of the project.

## Tools

### Swift Package Manager

The project is built with Swift Package Manager. You can find the definition in [`Package.swift`](../Package.swift) file.

### SwiftLint

We have set up [SwiftLint](https://github.com/realm/SwiftLint) to enforce Swift style and conventions.
You can run the following command to check if your code does not violate any of the rules.

```sh
swiftlint
```

### SwiftFormat

We have set up [SwiftFormat](https://github.com/nicklockwood/SwiftFormat) to enforce consistent code formatting. You can run the following command in the root project directory to format your code.

```sh
swiftformat .
```

## Project Structure

The file structure of xcdiff with comments is below.

```sh
.
├── CommandTests
│   └──Generated
├── Fixtures
├── Sources
│   ├── XCDiff              # main.swift
│   ├── XCDiffCommand       # command line interface
│   └── XCDiffCore
│       ├── Comparator      # all comparators
│       ├── Library         # helpers
│       └── ResultRenderer  # formaters
│           ├── Output
│           ├── ProjectResultRenderer
│           └── Renderer
└── Tests
    ├── XCDiffCommandTests
    └── XCDiffCoreTests
```

## Tests

### Fixtures

The project has a `Fixtures` folder that hosts sample projects that aid the development and testing of xcdiff.

For example, a quick way to test out a local version of xcdiff is via:

```sh
cd Fixtures
swift run xcdiff
```

That will run xcdiff against two sample projects that have a diverse set of differences. Those fixtures are also use as part of the automated [Command Tests](#command-tests).

### Command Tests

*Command Tests* (as we call them) are a very convenient type of integration test, they help to test command line and core layers of xcdiff as well as the integration with the underlying XcodeProj framework.

Each markdown file in `CommandTests` represents a single integration test. Those files follow a very specific pattern:

````md
# Command
```json
<JSON REPRESENTATION OF THE COMMAND>
```

# Expected exit code
<NUMBER>

# Expected output
```
<CONTENT OF THE OUTPUT>
```
````

Additionally there are predefined varaibles that can be used:
- `{ios_project_1}` - evaluates to `Fixtures/ios_project_1/Project.xcodeproj`
- `{ios_project_2}` - evaluates to `Fixtures/ios_project_2/Project.xcodeproj`

For example, the command:

```sh
xcdiff -p1 Fixtures/ios_project_1/Project.xcodeproj -p2 Fixtures/ios_project_2/Project.xcodeproj
```

is covered by the following integration test.

````md
# Command
```json
["-p1", "{ios_project_1}", "-p2", "{ios_project_2}"]
```

# Expected exit code
1

# Expected output
```
✅ TARGETS > NATIVE targets
✅ TARGETS > AGGREGATE targets
❌ SOURCES > "Project" target
✅ SOURCES > "ProjectTests" target
✅ SOURCES > "ProjectUITests" target

```
````

[`CommandTests/Generated`](../CommandTests/Generated) contains test files that are auto-generated by the script [`Scripts/generate_tests_commands_files.py`](../Scripts/generate_tests_commands_files.py). You can add further commands to the script to have it generate further tests.

Thanks to those tests, there is no need to write any new manual tests. We need to just focus on reviewing the new markdown files generated in  [`CommandTests/Generated`](../CommandTests/Generated) to make sure the files contain the expected output of your new comparator. Scan the file names in [`CommandTests/Generated`](../CommandTests/Generated) for your new dependency tag name or check `git status` for new markdown files if you have trouble finding the newly generated files by the script.

`generate_tests_commands_files.py` helps to generate the most obvious cases, like different permutations of the verbose or format options.

**IMPORTANT:** The script needs be updated and run every time we add a new comparator to re-generate the test cases.
